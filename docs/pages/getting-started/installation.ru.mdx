# Установка

Установка Prisma Client Rust происходит иначе, чем в большинстве проектов на Rust.

`prisma-client-rust` содержит строителей запросов, трейты (traits) и определения типов. Некоторые из них - например, `Direction` - могут использоваться в вашем собственном коде.

`prisma-client-rust-cli` содержит генератор Prisma и доступ к Prisma CLI, но не предоставляет исполняемый бинарный файл - его нужно создать самостоятельно.

Prisma Client Rust требует минимальной версии Rust v1.62.0.

## Создание исполняемого файла CLI

### Внутри вашего контейнера (crate)

Вначале, основная библиотека и пакет CLI должны быть добавлены в Cargo.toml вашего проекта:

```toml
[dependencies]
prisma-client-rust = { git = "https://github.com/Brendonovich/prisma-client-rust", tag = "0.6.8" }
prisma-client-rust-cli = { git = "https://github.com/Brendonovich/prisma-client-rust", tag = "0.6.8" }
```

Сгенерированому клиенту также потребуется `serde`, поэтому запустите `cargo add`, чтобы установить его:

```sh
cargo add serde
```

Вам также нужно убедиться, что вы используете 2021 редакцию Rust.

```toml
[package]
# ... package stuff
edition = "2021"
```

Самый простой способ создать бинарный файл для доступа к CLI - создать папку `src/bin`, если у вас ее еще нет, и внутри нее создать файл с именем, например, `prisma.rs` (это определит имя вашего бинарного файла).

```rust
fn main() {
    prisma_client_rust_cli::run();
}
```

Технически, этого достаточно! Просто запустите следующее, чтобы получить доступ к CLI:

```bash
$ cargo run --bin <название исполняемого файла> -- <комманда>
```

import { Callout } from "nextra/components";

<Callout type="info">
  Если вы используете Apple Silicon, рекомендуется убедиться, что Rosetta
  установлен, **даже если вы уже установили его ранее**. Запустите
  `softwareupdate --install-rosetta --agree-to-license`, чтобы в этом убедиться.
  В противном случае могут возникнуть неопределенные ошибки от двоичного файла
  `query-engine` Prisma.
</Callout>

Эту команду не очень удобно запускать. К счастью, Cargo позволяет нам определять псевдонимы для запуска команд на уровне проекта! Создайте папку в корне вашего проекта с именем `.cargo` и внутри нее создайте файл `config.toml`, содержащий следующее:

```toml
[alias]
prisma = "run --bin <название исполняемого файла> --"
```

Теперь вы можете запускать `cargo prisma <комманда>` в любом месте вашего проекта, чтобы получить доступ к CLI!

У этого подхода есть некоторые проблемы:

1. `prisma-client-rust-cli` включен в зависимости вашего контейнера (crate), что, вероятно, не желательно.
2. Если ваш контейнер (crate) содержит ошибки во время компиляции, то вы не сможете сгенерировать клиент, так как CLI также не сможет скомпилироваться!

К счастью существует более надежный способ:

### Как контейнер рабочей области (workspace crate)

Переместите бинарный файл CLI в отдельный контейнер (crate) и настройте ваш проект на использование [Cargo workspaces](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html).
Ниже представлен пример структуры проекта, который имеет одну целевую бинарную сборку в `src/main.rs`,
и отдельный контейнер для CLI с именем `prisma-cli`, который включен в члены рабочей области `Cargo.toml`.

```
Cargo.toml
.cargo/
    config.toml
src/
    main.rs
prisma-cli/
    Cargo.toml
    src/
        main.rs
```

Для примера выше `Cargo.toml` будет включать `prisma-client-rust` как зависимость, так как она требуется для сгенерированного файла, в то время как `prisma-cli/Cargo.toml` будет включать `prisma-client-rust-cli` как зависимость, и поэтому бинарный файл в `src/main.rs` не будет включать в себя весь код CLI, а только необходимый библиотечный код.

Вам также нужно обновить псевдоним `cargo prisma` для запуска нового контейнера (crate):

```toml
[alias]
prisma = "run -p <prisma crate name> --"
```

#### Замечание о виртуальных рабочих областях (virtual workspaces)

Если корневой `Cargo.toml` вашей рабочей области не имеет раздела `[package]` (только раздел `[workspace]`), то вы используете виртуальную рабочую область (virtual workspace).

Для того, чтобы компиляция Prisma Client Rust проходила успешно, вам нужно указать Cargo использовать версию 2 [feature resolver-а](https://doc.rust-lang.org/edition-guide/rust-2021/default-cargo-resolver.html).

```toml
[workspace]
# ... workspace stuff
resolver = "2"
```

Это не является необходимым для обычных рабочих областей и одиночных пакетов, так как они могут использовать `edition = "2021"`, но виртуальные рабочие области особенные по какой-то причине.

## Указание вашей базы данных

В версии 0.6.3 Prisma Client Rust позволяет указать точно, какие коннекторы баз данных использует ваш проект, чтобы избежать компиляции других коннекторов, которые поддерживает Prisma. Это сокращает время компиляции и размеры бинарных файлов.

Для начала, установите `default-features = false` для `prisma-client-rust` и `prisma-client-rust-cli`.
Затем добавьте каждую базу данных, которую вы хотите поддерживать, как функцию для обоих контейнеров (crate).
Возможные значения: `postgresql`, `mysql`, `sqlite`, `mssql` и `mongodb`.

## Почему не предоставляется бинарный файл CLI?

В старых версиях Prisma Client Rust была возможность использовать `cargo install prisma-client-rust-cli` и иметь глобальную установку CLI, доступную для использования в любое время.

Это предствляло собой большую проблему: Версионирование.
Управление несколькими проектами, которые использовали разные версии Prisma Client Rust, было очень неудобно, и это шло вразрез с рекомендуемыми инструкциями по установке Prisma Client
[JS](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-postgres),
[Go](https://github.com/prisma/prisma-client-go/blob/main/docs/quickstart.md),
и [Python](https://prisma-client-py.readthedocs.io/en/stable/#installing-prisma-client-python).

В отличии от этих трех языков, Rust (или, более точно, Cargo) не предоставляет метод для запуска бинарных файлов, доступных внутри зависимостей. Поскольку установка глобально доступного бинарного файла была исключена, предоставление CLI в виде библиотеки было рассмотрено как единственный другой вариант, плюс лично я считаю, что возможность запуска `cargo prisma <комманда>` - это довольно приятный опыт и соответствует клиентам на других языках.
